// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2465.Clyde.subsystems;

import org.usfirst.frc2465.Clyde.RobotMap;
import org.usfirst.frc2465.Clyde.RobotPreferences;
import org.usfirst.frc2465.Clyde.commands.*;
import org.usfirst.frc2465.Clyde.subsystems.Elevator.Motion;

import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.LimitSwitchNormal;
import com.ctre.phoenix.motorcontrol.LimitSwitchSource;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.DoubleSolenoid;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Drive extends PIDSubsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	double tolerance_degrees;

	public boolean autoStop = false;

	private final AHRS imu = RobotMap.imu;
	private final DoubleSolenoid leftGearShift = RobotMap.leftGearShift;
	private final DoubleSolenoid rightGearShift = RobotMap.rightGearShift;
	private final WPI_TalonSRX talon1 = RobotMap.talon1;
	private final WPI_TalonSRX talon2 = RobotMap.talon2;
	private final WPI_TalonSRX talon3 = RobotMap.talon3;
	private final WPI_TalonSRX talon4 = RobotMap.talon4;
	private final DifferentialDrive robotDrive = RobotMap.robotDrive;

	public enum Motion {
		FORWARD, BACK, STOP
	};

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Initialize your subsystem here
	public Drive() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
		// super("Drive", 1.0, 0.0, 0.0);
		super("Drive", RobotPreferences.getAutoRotateP(), RobotPreferences.getAutoRotateI(),
				RobotPreferences.getAutoRotateD(), 0.0, 0.02);
		try {
			getPIDController().setInputRange(-180, 180);
			getPIDController().setContinuous(true);
			getPIDController().setOutputRange(-1, 1);
			tolerance_degrees = RobotPreferences.getAutoRotateOnTargetToleranceDegrees();
			getPIDController().setAbsoluteTolerance(tolerance_degrees);
			setSetpoint(RobotPreferences.getAutoRotateDefaultTaretDegrees());
			disable();
		} catch (Exception e) {
			e.printStackTrace();
		}

		SmartDashboard.putNumber("RotateP", 0.024);
		SmartDashboard.putNumber("RotateI", 0.00000249);
		SmartDashboard.putNumber("RotateD", 0.06);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

		// Use these to get going:
		// setSetpoint() - Sets where the PID controller should move the system
		// to
		// enable() - Enables the PID controller.
	}

	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		setDefaultCommand(new StickDrive());
	}

	@Override
	protected double returnPIDInput() {
		// Return your input value for the PID loop
		// e.g. a sensor, like a potentiometer:
		// yourPot.getAverageVoltage() / kYourMaxVoltage;

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
		return imu.pidGet();

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
	}

	@Override
	protected void usePIDOutput(double output) {
		// Use output to drive your system, like a motor
		// e.g. yourMotor.set(output);

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
		SmartDashboard.putNumber("PID Out", output);

		output = -output; // Weird bug in PID system, values inputed into talons must be inverted.

		RobotMap.robotDrive.arcadeDrive(0.0, output, false);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	}

	public void arcadeDrive(double xSpeed, double zRotation) {

		if (getAutoRotation()) {
			// zRotation = next_autorotate_value;
		}

		SmartDashboard.putNumber("ZRotation", zRotation);
		SmartDashboard.putNumber("XSpeed", xSpeed);

		if (getAutoRotation() == false) {
			robotDrive.arcadeDrive(xSpeed, zRotation, false);
		}
	}

	public void updatePID() {
		getPIDController().setPID(SmartDashboard.getNumber("RotateP", 0.024), SmartDashboard.getNumber("RotateI", 0.00000249),
				SmartDashboard.getNumber("RotateD", 0.06));
	}

	public void setAutoRotation(boolean b) {
		// TODO Auto-generated method stub
		if (b) {
			getPIDController().enable();
		} else {
			getPIDController().disable();
		}
	}

	public void zeroEncoder() {
		RobotMap.talon1.setSelectedSensorPosition(0, 0, 0);
		RobotMap.talon3.setSelectedSensorPosition(0, 0, 0);
	}

	public double getLeftEncoder() {
		return RobotMap.talon1.getSelectedSensorPosition(0);
	}

	public double getRightEncoder() {
		return RobotMap.talon3.getSelectedSensorPosition(0);
	}

	public void setMotion(float lspeed, float rspeed) {

		talon1.set(-lspeed);
		talon3.set(rspeed);

	}

	public void configureAutoStop(int distance) {

		if (autoStop == false) {
			autoStop = true;


			talon1.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen, 0);
			talon1.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen, 0);
			talon3.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen, 0);
			talon3.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen, 0);

			
			talon1.configForwardSoftLimitThreshold(distance, 0);
			talon3.configForwardSoftLimitThreshold(distance, 0);
			talon1.configReverseSoftLimitThreshold(-distance, 0);
			talon3.configReverseSoftLimitThreshold(-distance, 0);
			

			talon1.configForwardSoftLimitEnable(true, 0);
			talon3.configForwardSoftLimitEnable(true, 0);
			talon1.configReverseSoftLimitEnable(true, 0);
			talon3.configReverseSoftLimitEnable(true, 0);
			
			
			//talon1.overrideLimitSwitchesEnable(true);
			//talon3.overrideLimitSwitchesEnable(true);
			
			//talon1.overrideSoftLimitsEnable(true);
			//talon3.overrideSoftLimitsEnable(true);
		}
	}

	public boolean isStopped() {

		boolean stopped = (talon1.getSensorCollection().isFwdLimitSwitchClosed() || talon1.getSensorCollection().isRevLimitSwitchClosed()) && (talon3.getSensorCollection().isFwdLimitSwitchClosed() || talon3.getSensorCollection().isRevLimitSwitchClosed());
		if (stopped) {
			talon1.configForwardSoftLimitEnable(false,0);
			talon1.configReverseSoftLimitEnable(false,0);
			talon3.configForwardSoftLimitEnable(false,0);
			talon3.configReverseSoftLimitEnable(false,0);
		}
		return stopped;
	}

	public boolean getAutoRotation() {
		SmartDashboard.putBoolean("AutoRotateEnabled", getPIDController().isEnabled());
		return getPIDController().isEnabled();
	}
}
