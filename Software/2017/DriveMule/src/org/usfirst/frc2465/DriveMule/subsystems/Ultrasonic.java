// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2465.StrongholdBot16.subsystems;

import java.io.UnsupportedEncodingException;

import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.SerialPort.Port;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Ultrasonic extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /***********************************************************/
    /* Runnable Interface Implementation                       */
    /***********************************************************/
    
    class IOThread implements Runnable {
    
        Thread              m_thread;
        boolean             stop;
        SerialPort			serial_port;
        double last_data_received_timestamp = 0;
        
        public void start(SerialPort serial_port) {
        	this.serial_port = serial_port;
            m_thread = new Thread(this);
            m_thread.start();
            stop = false;
        }
        
        final static int NUM_ULTRASONIC_SENSORS=5;
        final static int ULTRASONIC_SENSOR_SAMPLE_TIME_MS=33;
        final static int MS_PER_SEC=1000;
        
        private void reset_serial_port() {
        	/* Init serial port */
            try {
                serial_port.setReadBufferSize(256);
                serial_port.setTimeout(1.0);
                serial_port.enableTermination('\n');
                serial_port.flush();
                serial_port.reset();
            } catch (RuntimeException ex) {
                ex.printStackTrace();
            }        	
        }
        
        public void run() {
        	reset_serial_port();
            int remainder_bytes = 0;
            int update_rate_hz = MS_PER_SEC / (NUM_ULTRASONIC_SENSORS*ULTRASONIC_SENSOR_SAMPLE_TIME_MS);
        	while (!stop) {
        		/* Wait for a packet */
                try {
                    if ( !stop && ( remainder_bytes == 0 ) && ( serial_port.getBytesReceived() < 1 ) )
                        Timer.delay(1.0/update_rate_hz);
                    byte[] received_data = serial_port.read(256);
                    int bytes_read = received_data.length;
                    while (bytes_read > 0){
							String packet_string = new String(received_data, "US-ASCII");
		
	                    	/*  Break the packet into chunks, since doit only takes one */
	                    	// if short packet -- throw it away
	                    	if (bytes_read < 23){
	                    		reset_serial_port();
	                    		bytes_read = 0;
	                    		break;
	                    	}
	                    	if ( bytes_read >= 23 ) {
	                    		if (!Ultrasonic.this.doit(received_data)){
		                    		reset_serial_port();
		                    		bytes_read = 0;
		                    		break;
		                    	}                  	
	                    		last_data_received_timestamp = Timer.getFPGATimestamp();
	                    		if (bytes_read > 23 ){
	                    			//move buffer contents down
	                    			int j = 0;
	                    			for (int i=24;i<bytes_read-23 ;i++)received_data[j++]=received_data[i];	
	                    		}
	                    		bytes_read -= 23;
	                    	}
	                    }
                    } 
                    catch (RuntimeException | UnsupportedEncodingException ex) {
                    // This exception typically indicates a Timeout, but can also be a buffer overrun error.
                    ex.printStackTrace();
                    reset_serial_port();
                }                    
        	}
        }
   
        public void stop() {
        	stop = true;
        }
    }    
	public int frontRight;
	public int frontLeft;
	public int backRight;
	public int backLeft;
	public int frontCenter;
	IOThread io_thread;

	public Ultrasonic(SerialPort.Port port) {
        this.io_thread = new IOThread();
        SerialPort serial_port = new SerialPort(57600,port);
        this.io_thread.start(serial_port);
		// TODO Auto-generated constructor stub
		} 
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

	private boolean doit(byte[] packet) {
//                           1         2
//                 0123456789012345678901234
//String packet_string = "001,004,129,109,234AF\r\n";
		boolean checksum_ok = verifyChecksum(packet,0,19);
		try
		{
			if (checksum_ok) {
				String packet_string = new String(packet, "US-ASCII");		
				if ( packet[0] == (byte)'0' && 	
					 packet[3] == (byte)',' && 
					 packet[7] == (byte)',' && 
					 packet[11] ==(byte)',' && 
					 packet[15] ==(byte)','){
					frontRight = Integer.valueOf(packet_string.substring(0,3));
					frontLeft = Integer.valueOf(packet_string.substring(4,7));
					backLeft = Integer.valueOf(packet_string.substring(8,11));
					backRight = Integer.valueOf(packet_string.substring(12,15));
					frontCenter = Integer.valueOf(packet_string.substring(16,19));
					return true;
				}
			}
			return false;
		}
		catch(NumberFormatException ex){
			return false;
		} 
		catch (UnsupportedEncodingException e) {
			return false;
		}
	}
	
    public static byte decodeUint8(byte[] checksum, int offset) {
        byte first_digit = (byte) (checksum[0 + offset] <= '9' ? checksum[0 + offset] - '0' : ((checksum[0 + offset] - 'A') + 10));
        byte second_digit = (byte) (checksum[1 + offset] <= '9' ? checksum[1 + offset] - '0' : ((checksum[1 + offset] - 'A') + 10));
        byte decoded_checksum = (byte) ((first_digit * 16) + second_digit);
        return decoded_checksum;
    }
	
    public static boolean verifyChecksum(byte[] buffer, int offset, int content_length) {
        // Calculate Checksum
        byte checksum = 0;
        for (int i = 0; i < content_length; i++) {
            checksum += buffer[offset + i];
        }

        // Decode Checksum
        byte decoded_checksum = decodeUint8(buffer, offset + content_length);

        return (checksum == decoded_checksum);
    }
    public boolean isConnected() {
        double time_since_last_update = Timer.getFPGATimestamp() - this.io_thread.last_data_received_timestamp;
        return time_since_last_update <= 1.0;
    }
    public int getFrontRightDistanceCM() {
    	return frontRight;
    }
    public int getFrontLeftDistanceCM() {
    	return frontLeft;
    }
    public int getBackRightDistanceCM() {
    	return backRight;
    }
    public int getBackLeftDistanceCM() {
    	return backRight;
    }
    public int getFrontCenterDistanceCM() {
    	return frontCenter;
    }

    @Override
	public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
}


